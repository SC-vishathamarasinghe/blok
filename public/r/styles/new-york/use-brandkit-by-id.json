{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-brandkit-by-id",
  "type": "registry:hook",
  "dependencies": [
    "@sitecore/stream-ui-core"
  ],
  "files": [
    {
      "path": "registry/new-york/hooks/use-brandkit-by-id.ts",
      "content": "import { useCallback, useEffect, useMemo, useState } from \"react\"\nimport {\n  Brandkit,\n  brandkitFromApiResponse,\n  brandkitToPlainObject,\n  brands,\n  getBrandkitDisplayName,\n  GetBrandKitModelResponse,\n  getBrandkitTagsByCategory,\n  hasBrandkitLogo,\n  // HTTP error types\n  HTTPError,\n  isDeletedBrandkit,\n  // Domain utilities\n  isDraftBrandkit,\n  isLockedBrandkit,\n  isPublishedBrandkit,\n  // HeyAPI generated types\n  type GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData,\n} from \"@sitecore/stream-ui-core\"\n\n// Hook options type - using HeyAPI generated types\nexport type UseBrandkitByIdOptions =\n  GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData[\"path\"] &\n    (GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData[\"query\"] extends undefined\n      ? {}\n      : GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData[\"query\"])\n\nexport interface UseBrandkitsByIdProps {\n  // Existing properties (unchanged)\n  isLoading: boolean\n  brandkit: Brandkit | null\n  error: Error | null\n  refetch: () => Promise<void>\n\n  // New computed properties\n  displayName: string | null\n  hasLogo: boolean\n  isDraft: boolean\n  isPublished: boolean\n  isDeleted: boolean\n  isLocked: boolean\n  tagCategories: string[]\n  referenceCount: number\n\n  // New utility functions\n  utils: {\n    getTagsByCategory: (category: string) => readonly string[]\n    hasTag: (category: string, value: string) => boolean\n    canEdit: () => boolean\n    getStatusDisplay: () => string\n    getMetadata: <T = unknown>(key: string) => T | undefined\n    setMetadata: (key: string, value: unknown) => void\n    getAgeInDays: () => number\n    isRecentlyUpdated: (withinDays?: number) => boolean\n    serialize: () => Record<string, unknown>\n  }\n}\n\n/**\n * Hook to fetch a single brandkit by ID with enhanced utilities and computed properties.\n *\n * @param brandkitId - The ID of the brandkit to fetch. If empty, no fetch will occur.\n * @param options - Configuration options for the API request\n * @param options.organizationId - Required organization ID for the request\n * @param options.includeDeleted - Whether to include deleted brandkits in the response\n * @returns Object containing the brandkit data, loading state, error state, computed properties, and utility functions\n *\n * @example\n * // Basic usage\n * const { brandkit, isLoading, error } = useBrandkitById('brandkit-123', {\n *   organizationId: 'org-456'\n * });\n *\n * // Enhanced usage with computed properties\n * const {\n *   brandkit,\n *   displayName,\n *   isDraft,\n *   hasLogo,\n *   utils,\n *   isLoading\n * } = useBrandkitById('brandkit-123', { organizationId: 'org-456' });\n *\n * // Using utility functions\n * const canEdit = utils.canEdit();\n * const industryTags = utils.getTagsByCategory('industry');\n * const customData = utils.getMetadata<string>('customField');\n * utils.setMetadata('lastViewed', new Date().toISOString());\n *\n * // Using computed properties\n * if (isDraft) {\n *   console.log(`${displayName} is a draft brandkit`);\n * }\n *\n * if (hasLogo) {\n *   console.log(`${displayName} has a logo`);\n * }\n */\nexport function useBrandkitById(\n  brandkitId: string = \"\",\n  options?: Omit<UseBrandkitByIdOptions, \"brandkitId\">\n): UseBrandkitsByIdProps {\n  const [brandkit, setBrandkit] = useState<Brandkit | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  // Add local metadata state for mutations\n  const [localMetadata, setLocalMetadata] = useState<Record<string, unknown>>(\n    {}\n  )\n\n  const fetchBrandkit = useCallback(async () => {\n    if (!brandkitId) {\n      setBrandkit(null)\n      setIsLoading(false)\n      return\n    }\n\n    try {\n      setIsLoading(true)\n      setError(null)\n\n      const response =\n        await brands.getBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGet(\n          {\n            path: {\n              organizationId: options?.organizationId || \"\",\n              brandkitId: brandkitId,\n            },\n            query: {\n              includeDeleted: options?.includeDeleted,\n            },\n          }\n        )\n\n      setBrandkit(\n        response.data\n          ? brandkitFromApiResponse(response.data as GetBrandKitModelResponse)\n          : null\n      )\n    } catch (err) {\n      console.error(\"Brandkit fetch error:\", err)\n\n      // Handle ky HTTPError specifically\n      if (err instanceof HTTPError) {\n        setError(\n          new Error(\n            `API Error: ${err.response.status} - ${err.response.statusText}`\n          )\n        )\n      } else {\n        setError(\n          err instanceof Error ? err : new Error(\"Failed to fetch brandkit\")\n        )\n      }\n      setBrandkit(null)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [brandkitId, options?.organizationId, options?.includeDeleted])\n\n  useEffect(() => {\n    fetchBrandkit()\n  }, [brandkitId, options?.organizationId, options?.includeDeleted])\n\n  // Computed properties using useMemo for performance\n  const displayName = useMemo(\n    () => (brandkit ? getBrandkitDisplayName(brandkit) : null),\n    [brandkit]\n  )\n\n  const hasLogo = useMemo(\n    () => (brandkit ? hasBrandkitLogo(brandkit) : false),\n    [brandkit]\n  )\n\n  const isDraft = useMemo(\n    () => (brandkit ? isDraftBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const isPublished = useMemo(\n    () => (brandkit ? isPublishedBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const isDeleted = useMemo(\n    () => (brandkit ? isDeletedBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const isLocked = useMemo(\n    () => (brandkit ? isLockedBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const tagCategories = useMemo(\n    () =>\n      brandkit ? [...new Set(brandkit.tags.map((tag) => tag.category))] : [],\n    [brandkit]\n  )\n\n  const referenceCount = useMemo(\n    () => (brandkit ? brandkit.references.length : 0),\n    [brandkit]\n  )\n\n  // Utility functions bound to current brandkit\n  const utils = useMemo(\n    () => ({\n      /**\n       * Get all tag values for a specific category\n       */\n      getTagsByCategory: (category: string): readonly string[] =>\n        brandkit ? getBrandkitTagsByCategory(brandkit, category) : [],\n\n      /**\n       * Check if brandkit has a specific tag category/value combination\n       */\n      hasTag: (category: string, value: string): boolean =>\n        brandkit\n          ? getBrandkitTagsByCategory(brandkit, category).includes(value)\n          : false,\n\n      /**\n       * Check if brandkit can be edited (not locked and not deleted)\n       */\n      canEdit: (): boolean =>\n        brandkit\n          ? !isLockedBrandkit(brandkit) && !isDeletedBrandkit(brandkit)\n          : false,\n\n      /**\n       * Get user-friendly status display text\n       */\n      getStatusDisplay: (): string => {\n        if (!brandkit) return \"Not loaded\"\n        return (\n          brandkit.status.charAt(0).toUpperCase() + brandkit.status.slice(1)\n        )\n      },\n\n      /**\n       * Get metadata value with type safety\n       */\n      getMetadata: <T = unknown>(key: string): T | undefined => {\n        if (!brandkit) return undefined\n        const effectiveMetadata = { ...brandkit.metadata, ...localMetadata }\n        return effectiveMetadata[key] as T\n      },\n\n      /**\n       * Set local metadata (doesn't affect original brandkit)\n       */\n      setMetadata: (key: string, value: unknown): void => {\n        setLocalMetadata((prev) => ({ ...prev, [key]: value }))\n      },\n\n      /**\n       * Calculate age of brandkit in days\n       */\n      getAgeInDays: (): number => {\n        if (!brandkit) return 0\n        const now = new Date()\n        const created = brandkit.createdOn\n        return Math.floor(\n          (now.getTime() - created.getTime()) / (1000 * 60 * 60 * 24)\n        )\n      },\n\n      /**\n       * Check if brandkit was recently updated\n       */\n      isRecentlyUpdated: (withinDays: number = 7): boolean => {\n        if (!brandkit) return false\n        const now = new Date()\n        const updated = brandkit.updatedOn\n        const daysDiff = Math.floor(\n          (now.getTime() - updated.getTime()) / (1000 * 60 * 60 * 24)\n        )\n        return daysDiff <= withinDays\n      },\n\n      /**\n       * Serialize brandkit to plain object\n       */\n      serialize: (): Record<string, unknown> =>\n        brandkit ? brandkitToPlainObject(brandkit) : {},\n    }),\n    [brandkit, localMetadata]\n  )\n\n  return {\n    // Existing return values\n    isLoading,\n    brandkit,\n    error,\n    refetch: fetchBrandkit,\n\n    // New computed properties\n    displayName,\n    hasLogo,\n    isDraft,\n    isPublished,\n    isDeleted,\n    isLocked,\n    tagCategories,\n    referenceCount,\n\n    // New utilities\n    utils,\n  }\n}\n\n// Re-export domain utilities for convenience\nexport {\n  isDraftBrandkit,\n  isPublishedBrandkit,\n  isDeletedBrandkit,\n  isLockedBrandkit,\n  getBrandkitDisplayName,\n  hasBrandkitLogo,\n  getBrandkitTagsByCategory,\n  brandkitToPlainObject,\n  createBrandkit,\n  type BrandkitStatus,\n} from \"@sitecore/stream-ui-core\"\n",
      "type": "registry:hook"
    }
  ],
  "categories": [
    "stream",
    "hooks",
    "brandkit"
  ]
}